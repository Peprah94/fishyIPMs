library(reshape2)
# set working directory.
#change this for your particular application
setwd("C:/GitHub/fishyIPMs")
# catchment variables
catchmentVars <- read_csv("dataset/model_catchment_vars.csv")
colnames(catchmentVars)[2] <- "lakeID"
# Individual dataset
indData <- read_csv("dataset/Example2_vatnLnr.csv")
colnames(indData)[c(1:6,8:35)] <- c("lengthYrBefore",
"legthAtAgeThisYear",
"yearGrowthOcc",
"ageGrowthOcc",
"ageAtYr",
"fishID",
"climateZone",
"locationNumber",
"metersAboveSea",
"lineNumber",
"date",
"year",
"period",
"lakeName",
"lakeID",
"fishAge",
"fishLength",
"fishWeight",
"sex",
"maturationStage",
"maturation",
"ageAtGrowth",
"growth",
"instanteneousGrowth",
"capturePerUnitEffort",
"temperatureMeanInMay",
"temperatureMeanInJune",
"temperatureMeanInJuly",
"precipitationSumInMay",
"precipitationSumInJune",
"precipitationSumInJuly",
"temperatureMeanInSummer",
"precipitationSumDuringSummer",
"NAOwinterIndex")
indData <- indData[complete.cases(indData[, c("maturationStage", "maturation")]),] %>%
dplyr::mutate(maturationStage = as.numeric(maturationStage),
maturation = as.numeric(maturation),
presence = 1)
indDataWithCatchments <- indData %>%
right_join(catchmentVars, by = c("lakeID", "year"))%>%
dplyr::mutate(maturationStage = as.numeric(maturationStage),
maturation = as.numeric(maturation),
presence = 1)
unique(indDataWithCatchments$year)
unique(indData$year)
# load Population data
popnData <- read_delim("dataset/Example1.csv",
delim = ";",
escape_double = FALSE,
trim_ws = TRUE)
colnames(popnData)[c(2:5,8,10,12,16:25,29:30)] <- c("climateZone",
"lakeNumber",
"lineNumber",
"date",
"lakeName",
"gillnetNumber",
"gillnetMeshSize",
"speciesName",
"fishLength",
"fishWeight",
"fishFat",
"gonadWeight",
"sex",
"maturationStage",
"maturation",
"revisedMaturation",
"stomachContent",
"otoliothRadius",
"captureAge")
# remove NAs from some selected columns
popnData <- popnData[complete.cases(popnData[, c("maturationStage", "maturation")]),] %>%
dplyr::mutate(maturationStage = as.numeric(maturationStage),
maturation = as.numeric(maturation))
# Explore the relationship
r <- c(popnData[, 22])$maturationStage
s <- c(popnData[, 23])$maturation
table(s,r) #what is the relationship between maturation and maturation stage?
# data is collected in 2008
# create the age at harvest data
ageAtHarvestData <- dcast(indDataWithCatchments,
yearGrowthOcc + sex + lakeName ~ ageAtYr,
value.var = "presence",
fun.aggregate = sum)%>%
left_join(., indDataWithCatchments,
by = c("yearGrowthOcc", "sex", "lakeName"),
keep = FALSE,
multiple = "first")
# Now I get the data to model sprawning
# Use the idea in Magnus et.al 2021
#Select females and use the maturation variable (0/1) to model the sprawning probability
index <- function(x) {ifelse(x > 0, 1, 0)}
sprawningAtHarvestData <- indDataWithCatchments %>%
dplyr::mutate(maturation = ifelse(sex == 1, 0, maturation))%>% # I assume 1 is males
dcast(.,
yearGrowthOcc + sex + lakeName ~ ageAtYr,
value.var = "maturation",
fun.aggregate = sum)%>%
left_join(., indDataWithCatchments,
by = c("yearGrowthOcc", "sex", "lakeName"),
keep = FALSE,
multiple = "first")
dataList <- list(ageAtHarvestData = ageAtHarvestData,
sprawningData = sprawningAtHarvestData,
indData = indDataWithCatchments,
popnData = popnData)
save(dataList,
file = "dataset/formattedDataList.RData")
# set working directory.
#change this for your particular application
setwd("C:/GitHub/fishyIPMs")
# Load formatted data
load("dataset/formattedDataList.RData")
# Load required packages
library(nimble)
library(dplyr)
library(readr)
library(reshape2)
# Write nimble Function to calculate eigen values and extract the maximum
lambdaEstimation <- function(x){
ret <- max(Re(eigen(x)$values))
return(ret)
}
nimbleLambdaEstimation <- nimble::nimbleRcall(
prototype = function(x = double(2)){},
returnType = double(0),
Rfun = 'lambdaEstimation'
)
code <- nimbleCode({
#######################################
# Sprawning probability
###########################################
## Prior distributions
#covariate effect
for(i in 1:4){
bs[i] ~ dnorm(0, sd=10)
}
sdbs ~dunif(0.01, 10)
sdbsAge ~dunif(0.01, 10)
#treat sex as a factor in the sprawing probability
for(i in 1:2){
bsSex[i] ~ dnorm(0, sd=sdbs)
}
#treat each stage/age category as a factor for the spawning probability
for(age in 1:maxAge){
bsAge[age] ~ dnorm(0, sd=sdbsAge)
}
#variable selection Probability
for(k in 1:5){
psibs[k] ~ dunif(0,1)
}
# Sprawning probability
for(ind in 1:nInds){
for(age in 1:maxAge){ #loop through the age
logit(sprawnProb[ind, age]) <- bs[1] + bsAge[age] + psibs[1]*bs[2]*ageAtYear[ind] +  psibs[2]*bs[3]*lengthAtAgeThisYear[ind]  + psibs[3]*bs[3]*ageAtYear[ind]*lengthAtAgeThisYear[ind] + psibs[4]*bs[4]*CPUE[ind] +psibs[5]* bsSex[sex[ind]]
}
}
for(ind in 1:nInds){
for(age in 1:maxAge){ #loop through the age
sprawns[ind, age] ~ dbern(sprawnProb[ind, age])
}
}
# Fecundicity
for(ind in 1:nInds){
for(age in 1:maxAge){ #loop through the age
fecundicity[ind, age] <- exp(log(lengthAtAgeThisYear[ind])*2.21 - 6.15) * sprawnProb[ind, age]
}
}
##############################################
# survival probability
###########################################
#prior distributions
for(i in 1:2){
bsurv[i] ~dnorm(0, sd = 10)
}
sdSurvAge ~ dunif(0.01, 10)
sdLake ~ dunif(0.01, 10)
for(i in 1:maxAge){
bsurvAge[i]~dnorm(0, sd = sdSurvAge)
}
#lake effect
for(i in 1:nLakes){
bsLake[i] ~dnorm(0, sd = sdLake)
}
for(ind in 1:nInds){
for(age in 1:maxAge){ #loop through the age
logit(survivalProb[ind, age]) <- bsurv[1] + bsurvAge[age] + bsurv[2]* yearGrowthOcc[ind] + bsLake[lake[ind]]
}
}
## Population size
# Initialise the population size nodes
#Amat[1:10, 1:10 ,1:nInds] <- 0
for(ind in 1:nInds){
Amat[1,1 ,ind] <-  fecundicity[ind, 1]*survivalProb[ind, 1]
for(age in 2:maxAge){ #loop through the age
Amat[1,age ,ind] <-  fecundicity[ind, age]*survivalProb[ind, 1]
Amat[age,(age-1),ind] <-  survivalProb[ind, age]
}
Amat[maxAge, maxAge, ind] <- survivalProb[maxAge, maxAge]
#  }
# Define population size
#  for(ind in 1:nInds){
#   N[1:maxAge, 1, ind] <- Nst[1:maxAge]
#   for(t in 2:T){
#Population projection
#  N[1:maxAge, t, ind] <- Amat[1:maxAge, 1:maxAge,ind]%*%N[1:maxAge, t-1, ind]
#annual growth rate on log-scale
# r.annual[t, ind] <- log(sum(N[1:maxAge, t, ind])) - log(sum(N[1:maxAge, t-1, ind]))
}
#}
# Growth rate (lambda) for each individual
for(ind in 1:nInds){
#lambda[ind] <- exp(mean(r.annual[u:T, ind]))
lambda[ind] <- nimbleLambdaEstimation(Amat[1:maxAge, 1:maxAge, ind])
# Proportion of stable distribution
# check skelly et. al (2023) page 1066 for equations
# w = proportion to stable age
# z = probability of remaining in the same age class
# g = probability of surving to the next stage class
w[ind, 1] <- 1
g[ind, 1] <- Amat[1,1,ind]
g[ind, maxAge] <- 0
z[ind, 1] <- 0
z[ind, maxAge] <- Amat[maxAge,maxAge - 1,ind]
for(age in 2:(maxAge-1)){
z[ind, age] <- 0
g[ind, age] <- Amat[age,(age-1),ind]
w[ind, age] <- (g[ind, age-1]/(lambda[ind] -z[ind, age]))*w[ind, age-1]
}
w[ind, maxAge] <- (g[ind, maxAge]/(lambda[ind] -z[ind, maxAge]))*w[ind, maxAge-1]
#stable state distribution
C[ind, 1:maxAge] <- w[ind, 1:maxAge]/sum(w[ind, 1:maxAge])
#expected counts in each stage class
for(age in 2:(maxAge)){
ey[ind, age] <- g[ind, age-1]*C[ind, age-1] + z[ind, age]*C[ind, age]
}
#ey[ind, maxAge] <- g[ind, maxAge-1]*C[ind, maxAge-1] + survivalProb[ind, maxAge]*C[ind, maxAge]
ey[ind, 1] <- (lambda[ind] - sum(ey[ind, 2:maxAge]))
# likelihood
#theta[ind, 1:maxAge] ~ ddirch(ey[ind, 1:maxAge])
y[ind, 1:maxAge] ~ dmulti(ey[ind, 1:maxAge], harvestCount[ind])
}
}
)
sprawnsData <- apply(dataList$sprawningData[, 4:13], c(1,2), function(x) ifelse(x>0, 1, 0))
data = list(
#sprawns = as.numeric(dataList$sprawningData$maturation),
sprawns = sprawnsData,
ageAtYear = as.numeric(dataList$sprawningData$ageAtYr),
lengthAtAgeThisYear = as.numeric(dataList$sprawningData$legthAtAgeThisYear),
CPUE = as.numeric(dataList$sprawningData$capturePerUnitEffort),
yearGrowthOcc = as.numeric(as.factor(dataList$ageAtHarvestData$yearGrowthOcc)),
y = as.matrix(dataList$ageAtHarvestData[ ,4: 13]),
harvestCount = rowSums(as.matrix(dataList$ageAtHarvestData[4: 13]))
)
constants = list(
nInds = nrow(dataList$ageAtHarvestData),
sex = as.numeric(dataList$sprawningData$sex),
lake = as.numeric(as.factor(dataList$ageAtHarvestData$lakeName)),
nLakes = length(unique(as.numeric(as.factor(dataList$ageAtHarvestData$lakeName)))),
maxAge = 10,
Nst = rep(3, 10),
T = 100,
u = 80 # cut off year from the prediction of population size used to estimate popn growth rate
)
inits <- list(
bs = rnorm(4, 0, 1),
bsSex = rnorm(2, 0, 1),
bsAge = rnorm(constants$maxAge, 0, 1),
sdbsAge =1,
sdLake = 1,
bsLake = rnorm(constants$nLakes, 0, 1),
sdbs = 1,
psibs = rep(0.5, 5),
bsurv = rnorm(2, 0, 1),
bsurvAge = rnorm(constants$maxAge, 0, 1),
sdSurvAge = 1,
Amat = array(0, dim = c(10,10, constants$nInds)),
N = array(10, dim = c(10,constants$T, constants$nInds)),
theta <- matrix(0.1, nrow = constants$maxAge, ncol = constants$nInds)
)
# nimbleModel
fishModel <- nimbleModel(code,
data = data,
constants = constants,
inits = inits)
as.numeric(dataList$sprawningData$ageAtYr)
as.numeric(dataList$sprawningData$legthAtAgeThisYear)
as.numeric(dataList$sprawningData$capturePerUnitEffort)
as.numeric(as.factor(dataList$ageAtHarvestData$yearGrowthOcc))
as.matrix(dataList$ageAtHarvestData[ ,4: 13])
rowSums(as.matrix(dataList$ageAtHarvestData[4: 13])
)
sprawningAtHarvestData
ageAtHarvestData
View(ageAtHarvestData)
# data is collected in 2008
# create the age at harvest data
ageAtHarvestData <- indDataWithCatchments[complete.cases(indDataWithCatchments[, c("ageAtYr", "sex")]),]%>%
dcast(.,
yearGrowthOcc + sex + lakeName ~ ageAtYr,
value.var = "presence",
fun.aggregate = sum)%>%
left_join(., indDataWithCatchments,
by = c("yearGrowthOcc", "sex", "lakeName"),
keep = FALSE,
multiple = "first")
sprawningAtHarvestData <- indDataWithCatchments[complete.cases(indDataWithCatchments[, c("ageAtYr", "sex")]),]%>%
dplyr::mutate(maturation = ifelse(sex == 1, 0, maturation))%>% # I assume 1 is males
dcast(.,
yearGrowthOcc + sex + lakeName ~ ageAtYr,
value.var = "maturation",
fun.aggregate = sum)%>%
left_join(., indDataWithCatchments,
by = c("yearGrowthOcc", "sex", "lakeName"),
keep = FALSE,
multiple = "first")
sprawningAtHarvestData
View(sprawningAtHarvestData)
dataList <- list(ageAtHarvestData = ageAtHarvestData,
sprawningData = sprawningAtHarvestData,
indData = indDataWithCatchments,
popnData = popnData)
save(dataList,
file = "dataset/formattedDataList.RData")
# set working directory.
#change this for your particular application
setwd("C:/GitHub/fishyIPMs")
# Load formatted data
load("dataset/formattedDataList.RData")
# Load required packages
library(nimble)
library(dplyr)
library(readr)
library(reshape2)
# Write nimble Function to calculate eigen values and extract the maximum
lambdaEstimation <- function(x){
ret <- max(Re(eigen(x)$values))
return(ret)
}
nimbleLambdaEstimation <- nimble::nimbleRcall(
prototype = function(x = double(2)){},
returnType = double(0),
Rfun = 'lambdaEstimation'
)
code <- nimbleCode({
#######################################
# Sprawning probability
###########################################
## Prior distributions
#covariate effect
for(i in 1:4){
bs[i] ~ dnorm(0, sd=10)
}
sdbs ~dunif(0.01, 10)
sdbsAge ~dunif(0.01, 10)
#treat sex as a factor in the sprawing probability
for(i in 1:2){
bsSex[i] ~ dnorm(0, sd=sdbs)
}
#treat each stage/age category as a factor for the spawning probability
for(age in 1:maxAge){
bsAge[age] ~ dnorm(0, sd=sdbsAge)
}
#variable selection Probability
for(k in 1:5){
psibs[k] ~ dunif(0,1)
}
# Sprawning probability
for(ind in 1:nInds){
for(age in 1:maxAge){ #loop through the age
logit(sprawnProb[ind, age]) <- bs[1] + bsAge[age] + psibs[1]*bs[2]*ageAtYear[ind] +  psibs[2]*bs[3]*lengthAtAgeThisYear[ind]  + psibs[3]*bs[3]*ageAtYear[ind]*lengthAtAgeThisYear[ind] + psibs[4]*bs[4]*CPUE[ind] +psibs[5]* bsSex[sex[ind]]
}
}
for(ind in 1:nInds){
for(age in 1:maxAge){ #loop through the age
sprawns[ind, age] ~ dbern(sprawnProb[ind, age])
}
}
# Fecundicity
for(ind in 1:nInds){
for(age in 1:maxAge){ #loop through the age
fecundicity[ind, age] <- exp(log(lengthAtAgeThisYear[ind])*2.21 - 6.15) * sprawnProb[ind, age]
}
}
##############################################
# survival probability
###########################################
#prior distributions
for(i in 1:2){
bsurv[i] ~dnorm(0, sd = 10)
}
sdSurvAge ~ dunif(0.01, 10)
sdLake ~ dunif(0.01, 10)
for(i in 1:maxAge){
bsurvAge[i]~dnorm(0, sd = sdSurvAge)
}
#lake effect
for(i in 1:nLakes){
bsLake[i] ~dnorm(0, sd = sdLake)
}
for(ind in 1:nInds){
for(age in 1:maxAge){ #loop through the age
logit(survivalProb[ind, age]) <- bsurv[1] + bsurvAge[age] + bsurv[2]* yearGrowthOcc[ind] + bsLake[lake[ind]]
}
}
## Population size
# Initialise the population size nodes
#Amat[1:10, 1:10 ,1:nInds] <- 0
for(ind in 1:nInds){
Amat[1,1 ,ind] <-  fecundicity[ind, 1]*survivalProb[ind, 1]
for(age in 2:maxAge){ #loop through the age
Amat[1,age ,ind] <-  fecundicity[ind, age]*survivalProb[ind, 1]
Amat[age,(age-1),ind] <-  survivalProb[ind, age]
}
Amat[maxAge, maxAge, ind] <- survivalProb[maxAge, maxAge]
#  }
# Define population size
#  for(ind in 1:nInds){
#   N[1:maxAge, 1, ind] <- Nst[1:maxAge]
#   for(t in 2:T){
#Population projection
#  N[1:maxAge, t, ind] <- Amat[1:maxAge, 1:maxAge,ind]%*%N[1:maxAge, t-1, ind]
#annual growth rate on log-scale
# r.annual[t, ind] <- log(sum(N[1:maxAge, t, ind])) - log(sum(N[1:maxAge, t-1, ind]))
}
#}
# Growth rate (lambda) for each individual
for(ind in 1:nInds){
#lambda[ind] <- exp(mean(r.annual[u:T, ind]))
lambda[ind] <- nimbleLambdaEstimation(Amat[1:maxAge, 1:maxAge, ind])
# Proportion of stable distribution
# check skelly et. al (2023) page 1066 for equations
# w = proportion to stable age
# z = probability of remaining in the same age class
# g = probability of surving to the next stage class
w[ind, 1] <- 1
g[ind, 1] <- Amat[1,1,ind]
g[ind, maxAge] <- 0
z[ind, 1] <- 0
z[ind, maxAge] <- Amat[maxAge,maxAge - 1,ind]
for(age in 2:(maxAge-1)){
z[ind, age] <- 0
g[ind, age] <- Amat[age,(age-1),ind]
w[ind, age] <- (g[ind, age-1]/(lambda[ind] -z[ind, age]))*w[ind, age-1]
}
w[ind, maxAge] <- (g[ind, maxAge]/(lambda[ind] -z[ind, maxAge]))*w[ind, maxAge-1]
#stable state distribution
C[ind, 1:maxAge] <- w[ind, 1:maxAge]/sum(w[ind, 1:maxAge])
#expected counts in each stage class
for(age in 2:(maxAge)){
ey[ind, age] <- g[ind, age-1]*C[ind, age-1] + z[ind, age]*C[ind, age]
}
#ey[ind, maxAge] <- g[ind, maxAge-1]*C[ind, maxAge-1] + survivalProb[ind, maxAge]*C[ind, maxAge]
ey[ind, 1] <- (lambda[ind] - sum(ey[ind, 2:maxAge]))
# likelihood
#theta[ind, 1:maxAge] ~ ddirch(ey[ind, 1:maxAge])
y[ind, 1:maxAge] ~ dmulti(ey[ind, 1:maxAge], harvestCount[ind])
}
}
)
sprawnsData <- apply(dataList$sprawningData[, 4:13], c(1,2), function(x) ifelse(x>0, 1, 0))
sprawnsData
data = list(
#sprawns = as.numeric(dataList$sprawningData$maturation),
sprawns = sprawnsData,
ageAtYear = as.numeric(dataList$sprawningData$ageAtYr),
lengthAtAgeThisYear = as.numeric(dataList$sprawningData$legthAtAgeThisYear),
CPUE = as.numeric(dataList$sprawningData$capturePerUnitEffort),
yearGrowthOcc = as.numeric(as.factor(dataList$ageAtHarvestData$yearGrowthOcc)),
y = as.matrix(dataList$ageAtHarvestData[ ,4: 13]),
harvestCount = rowSums(as.matrix(dataList$ageAtHarvestData[4: 13]))
)
constants = list(
nInds = nrow(dataList$ageAtHarvestData),
sex = as.numeric(dataList$sprawningData$sex),
lake = as.numeric(as.factor(dataList$ageAtHarvestData$lakeName)),
nLakes = length(unique(as.numeric(as.factor(dataList$ageAtHarvestData$lakeName)))),
maxAge = 10,
Nst = rep(3, 10),
T = 100,
u = 80 # cut off year from the prediction of population size used to estimate popn growth rate
)
inits <- list(
bs = rnorm(4, 0, 1),
bsSex = rnorm(2, 0, 1),
bsAge = rnorm(constants$maxAge, 0, 1),
sdbsAge =1,
sdLake = 1,
bsLake = rnorm(constants$nLakes, 0, 1),
sdbs = 1,
psibs = rep(0.5, 5),
bsurv = rnorm(2, 0, 1),
bsurvAge = rnorm(constants$maxAge, 0, 1),
sdSurvAge = 1,
Amat = array(0, dim = c(10,10, constants$nInds)),
N = array(10, dim = c(10,constants$T, constants$nInds)),
theta <- matrix(0.1, nrow = constants$maxAge, ncol = constants$nInds)
)
# nimbleModel
fishModel <- nimbleModel(code,
data = data,
constants = constants,
inits = inits)
