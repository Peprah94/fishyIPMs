bl[i] ~ dnorm(0, sd = 10)
}
for(i in 1:nLakes){
blLake[i] ~ dnorm(0, sd = sdblLake)
}
for(i in 1:nSex){
blSex[i] ~ dnorm(0, sd = sdblSex)
}
for(i in 1:maxAge){
blAge[i] ~dnorm(0, sd= sdblAge)
}
for(i in 1:5){
pbLength[i] ~ dunif(0,1)
}
# + blSpecies[speciesID[ind]]
for(ind in 1:nInds){
for(age in 1:maxAge){
lengthLinearPred[ind, age] <- blAge[age]  + blSex[sexID[ind]] + blLake[lakeID[ind]] + bl[1] + pbLength[1]*bl[2]*year[ind] + pbLength[2]*bl[3]*summerTemp[ind] + pbLength[3]*bl[4]*summerSnowDepth[ind] + pbLength[4]*bl[5]*forest[ind] + pbLength[5]*bl[6]*WPUE[ind]
#lengthLinearPred[ind, age] <- blAge[age]  + blSex[sexID[ind]] + blLake[lakeID[ind]] + bl[1] + pbLength[1]*bl[2]*year[ind] + pbLength[2]*bl[3]*summerTemp[ind] + pbLength[3]*bl[4]*summerSnowDepth[ind] +pbLength[4]* bl[5]*forest[ind]
lengthAtAgeThisYear[ind, age] ~ dnorm(lengthLinearPred[ind, age], sd = sdEpsilon)
}
}
}
)
#spawnsData <- apply(dataList$sprawningData[, 4:17], c(1,2), function(x) ifelse(x>0, 1, 0))
wpue = as.numeric(scale(dataList$ageAtHarvestData$WPUE))
wpue[is.na(wpue)] <- mean(wpue, na.rm = TRUE)
data = list(
#sprawns = as.numeric(dataList$sprawningData$maturation),
#spawns = spawnsData,
ageAtYear = as.numeric(dataList$sprawningData$ageAtYear),
lengthAtAgeThisYear = log(as.matrix(dataList$lengthAtAgeData[ ,4: 17])),#as.numeric(dataList$sprawningData$legthAtAgeThisYear),
# CPUE = as.numeric(dataList$sprawningData$capturePerUnitEffort),
year = as.numeric(scale(dataList$ageAtHarvestData$year)),#as.numeric(as.factor(dataList$ageAtHarvestData$yearGrowthOcc)),
y = as.matrix(dataList$ageAtHarvestData[ ,4:17]),
harvestCount = rowSums(as.matrix(dataList$ageAtHarvestData[4:17])),
#temp = as.numeric(scale(dataList$ageAtHarvestData$temperatureMeanInJuly)),
# precMay = as.numeric(scale(dataList$ageAtHarvestData$precipitationSumInMay)),
#precJune = as.numeric(scale(dataList$ageAtHarvestData$precipitationSumInJune)),
# precJuly = as.numeric(scale(dataList$ageAtHarvestData$precipitationSumInJuly)),
forest = as.numeric(scale(dataList$ageAtHarvestData$`Coniferous forest`)),
# moorsAndHeathland = as.numeric(scale(dataList$ageAtHarvestData$`Moors and heathland`)),
# peatBogs = as.numeric(scale(dataList$ageAtHarvestData$`Peat bogs`)),
# waterbodies = as.numeric(scale(dataList$ageAtHarvestData$`Water bodies`)),
# broadleavedForest = as.numeric(scale(dataList$ageAtHarvestData$`Broad-leaved forest`)),
#sparselyVegAreas = as.numeric(scale(dataList$ageAtHarvestData$`Sparsely vegetated areas`)),
#meanDVI = as.numeric(dataList$ageAtHarvestData$mean_ndvi),
#transitionalWoodland = as.numeric(scale(dataList$ageAtHarvestData$`Transitional woodland-shrub`)),
#landOccByAgric = as.numeric(scale(dataList$ageAtHarvestData$`Land principally occupied by agriculture, with significant areas of natural vegetation`)),
#discontUrbanFabric = as.numeric(scale(dataList$ageAtHarvestData$`Discontinuous urban fabric`)),
# mixedForest = as.numeric(scale(dataList$ageAtHarvestData$`Mixed forest`)),
#seaAndOcean = as.numeric(scale(dataList$ageAtHarvestData$`Sea and ocean`)),
#bareRocks = as.numeric(scale(dataList$ageAtHarvestData$`Bare rocks`)),
#glaciersAndPerpetualSnow = as.numeric(scale(dataList$ageAtHarvestData$`Glaciers and perpetual snow`)),
#complexCultivationPatterns = as.numeric(scale(dataList$ageAtHarvestData$`Complex cultivation patterns`)),
#sportsAndLeisureFacilities = as.numeric(scale(dataList$ageAtHarvestData$`Sport and leisure facilities`)),
#greenUrbanAreas = as.numeric(scale(dataList$ageAtHarvestData$`Green urban areas`)),
#pastures = as.numeric(scale(dataList$ageAtHarvestData$Pastures)),
summerTemp = as.numeric(scale(dataList$ageAtHarvestData$meanSummerTemp)),
#summerPrec = as.numeric(scale(dataList$ageAtHarvestData$summerPrecipitation)),
summerSnowDepth = as.numeric(scale(dataList$ageAtHarvestData$meanWinterSnow)),
popnDensity = as.numeric(scale(dataList$ageAtHarvestData$pop_density)),
WPUE = wpue
# NAO = as.numeric(dataList$ageAtHarvestData$NAOwinterIndex)
)
constants = list(
nInds = nrow(dataList$ageAtHarvestData),
sexID = as.numeric(dataList$sprawningData$sex),
nSex = length(unique(as.numeric(dataList$sprawningData$sex))),
lakeID = as.numeric(as.factor(dataList$ageAtHarvestData$InnsjoNr)),
nLakes = length(unique(as.numeric(as.factor(dataList$ageAtHarvestData$InnsjoNr)))),
maxAge = dim(data$y)[2],
speciesID = as.numeric(as.factor(dataList$ageAtHarvestData$speciesID)),
nSpecies = length(unique(as.numeric(as.factor(dataList$ageAtHarvestData$speciesID))))
)
inits <- list(
pbLength = rep(0.5, 5),
bsp = rnorm(5, 0, 1),
bl = rnorm(6, 0, 1),
bsurv = rnorm(22, 0, 1),
blSex = rnorm(constants$nSex, 0, 1),
blSpecies = rnorm(constants$nSpecies, 0, 1),
blAge = rnorm(constants$maxAge, 0, 1),
blLake = rnorm(constants$nLakes, 0,1),
bspSex = rnorm(constants$nSex, 0, 1),
bspSpecies = rnorm(constants$nSpecies, 0, 1),
bspAge = rnorm(constants$maxAge, 0, 1),
bspLake = rnorm(constants$nLakes, 0,1),
bsurvSex = rnorm(constants$nSex, 0, 1),
bsurvSpecies = rnorm(constants$nSpecies, 0, 1),
bsurvAge = rnorm(constants$maxAge, 0, 1),
bsurvLake = rnorm(constants$nLakes, 0,1),
sdblSex = 1,
sdblSpecies = 1,
sdblAge = 1,
sdblLake = 1,
sdbspSex = 1,
sdbspSpecies = 1,
sdbspAge = 1,
sdbspLake = 1,
sdbsurvSex = 1,
sdbsurvSpecies = 1,
sdbsurvAge = 1,
sdbsurvLake = 1,
Amat = array(0, dim = c(constants$maxAge,constants$maxAge, constants$nInds)),
sdEpsilon = 1,
N = array(10, dim = c(constants$maxAge,constants$T, constants$nInds)),
theta = matrix(0.1, nrow = constants$maxAge, ncol = constants$nInds),
sprawnProb = 0.1
)
# nimbleModel
fishModel <- nimbleModel(code,
data = data,
constants = constants,
inits = inits)
# compile nimbleModel
fishModelCompiled <- compileNimble(fishModel)
fishModelConfigured <- configureMCMC(fishModelCompiled,
monitors = c("bl", "blLake", "blAge", "blSex",
"sdblLake", "sdblAge", "sdblSex",
"lengthAtAgeThisYear", "sdEpsilon",
"pbLength")
)
# Build and run model
fishModelBuilt <- buildMCMC(fishModelConfigured)
# compile built model
fishModelCompiled2 <- compileNimble(fishModelBuilt,
project = fishModelCompiled)
#run MCMC
lengthAtAgeModelRun <- runMCMC(fishModelCompiled2,
niter = 30000,
nchains = 2,
nburnin = 10000,
thin = 2,
setSeed = TRUE,
samples = TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
#check summary
lengthAtAgePosteriorSummary <- list()
lengthAtAgePosteriorSummary$data <- matrix(lengthAtAgeModelRun$summary$all.chains[rownames(lengthAtAgeModelRun$summary$all.chains)[grepl("lengthAtAge", rownames(lengthAtAgeModelRun$summary$all.chains))] , "Mean"],
nrow = constants$nInds,
ncol = constants$maxAge,
byrow = FALSE)
lengthAtAgePosteriorSummary$summary <- lengthAtAgeModelRun$summary$all.chains[rownames(lengthAtAgeModelRun$summary$all.chains)[!grepl("lengthAtAge", rownames(lengthAtAgeModelRun$summary$all.chains))] , ]
lengthAtAgePosteriorSummary$summary
save(lengthAtAgePosteriorSummary, file = "result/fittedModelLengthAtAge.RData")
# set working directory.
#change this for your particular application
setwd("C:/GitHub/fishyIPMs/NewDataset")
# Load formatted data
load("dataset/formattedDataList.RData")
#load the predictions of the lengthAtAge
load("result/fittedModelLengthAtAge.RData")
# Load required packages
library(nimble)
library(dplyr)
library(readr)
library(reshape2)
# Write nimble Function to calculate eigen values and extract the maximum
lambdaEstimation <- function(x){
ret <- max(Re(eigen(x)$values))
return(ret)
}
nimbleLambdaEstimation <- nimble::nimbleRcall(
prototype = function(x = double(2)){},
returnType = double(0),
Rfun = 'lambdaEstimation'
)
code <- nimbleCode({
############################
# We assume that spawning probability is constant across the year ans
# assume a prior for the spawning probability
###########################
spawnProb ~ dunif(0.0001, 0.3)
#############################
# Fecundicity
#############################
for(ind in 1:nInds){
for(age in 1:maxAge){ #loop through the age
fecundicity[ind, age] <- exp(log(exp(lengthAtAgeThisYear[ind, age]))*2.21 - 6.15) * spawnProb
}
}
##############################################
# survival probability
###########################################
#prior distributions
for(i in 1:13){
bsurv[i] ~dnorm(0, sd = 10)
}
sdbsurvAge ~ dunif(0.01, 10)
sdbsurvLake ~ dunif(0.01, 10)
sdbsurvSex ~ dunif(0.01, 10)
for(i in 1:maxAge){
bsurvAge[i]~dnorm(0, sd = sdbsurvAge)
}
# variable selection parameters
for(i in 1:12){
psi[i] ~ dunif(0,1)
}
#lake effect
for(i in 1:nLakes){
bsurvLake[i] ~dnorm(0, sd = sdbsurvLake)
}
for(i in 1:nSex){
bsurvSex[i] ~ dnorm(0, sd = sdbsurvSex)
}
for(ind in 1:nInds){
for(age in 1:maxAge){ #loop through the age
#logit(survivalProb[ind, age]) <- bsurv[1] + bsurvAge[age] + bsurvLake[lakeID[ind]] + bsurvSex[sexID[ind]] + psi[1] * bsurv[2]* year[ind]  + psi[2] * bsurv[3]*forest[ind] + psi[3] * bsurv[4]*pastures[ind] + psi[4] * bsurv[5]*popnDensity[ind] + psi[5] * bsurv[6]*summerTemp[ind] + psi[6] * bsurv[7]*summerPrec[ind] + psi[7] * bsurv[8]*summerSnowDepth[ind]  + psi[8] * bsurv[9]*forestsq[ind] + psi[9] * bsurv[10]*pasturessq[ind] + psi[10] * bsurv[11]*popnDensitysq[ind] + psi[11] * bsurv[12]*summerTempsq[ind] + psi[12] * bsurv[13]*summerPrecsq[ind] + psi[13] * bsurv[14]*summerSnowDepthsq[ind]
logit(survivalProb[ind, age]) <- bsurv[1] + bsurvAge[age] + bsurvLake[lakeID[ind]] + bsurvSex[sexID[ind]] + psi[1] * bsurv[2]* year[ind]  + psi[2] * bsurv[3]*forest[ind] + psi[3] *bsurv[4]*pastures[ind] + psi[4] *bsurv[5]*popnDensity[ind] + psi[5] *bsurv[6]*summerTemp[ind] + psi[6] *bsurv[7]*summerSnowDepth[ind]  + psi[7] *bsurv[8]*forestsq[ind] + psi[8] *bsurv[9]*pasturessq[ind] + psi[9] *bsurv[10]*popnDensitysq[ind] + psi[10] *bsurv[11]*summerTempsq[ind] + psi[11] *bsurv[12]*summerSnowDepthsq[ind] + psi[12] *bsurv[13]*WPUE[ind]
}
}
## Population size
# Initialise the population size nodes
#Amat[1:10, 1:10 ,1:nInds] <- 0
for(ind in 1:nInds){
Amat[1,1 ,ind] <-  fecundicity[ind, 1]*survivalProb[ind, 1]
for(age in 2:maxAge){ #loop through the age
Amat[1,age ,ind] <-  fecundicity[ind, age]*survivalProb[ind, 1]
Amat[age,(age-1),ind] <-  survivalProb[ind, age]
}
Amat[maxAge, maxAge, ind] <- survivalProb[ind, maxAge]
}
#}
# Growth rate (lambda) for each individual
for(ind in 1:nInds){
#lambda[ind] <- exp(mean(r.annual[u:T, ind]))
lambda[ind] <- nimbleLambdaEstimation(Amat[1:maxAge, 1:maxAge, ind])
# Proportion of stable distribution
# check skelly et. al (2023) page 1066 for equations
# w = proportion to stable age
# z = probability of remaining in the same age class
# g = probability of surving to the next stage class
w[ind, 1] <- 1
g[ind, 1] <- Amat[1,1,ind]
g[ind, maxAge] <- 0
z[ind, 1] <- 0
z[ind, maxAge] <- Amat[maxAge,maxAge - 1,ind]
for(age in 2:(maxAge-1)){
z[ind, age] <- 0
g[ind, age] <- Amat[age,(age-1),ind]
w[ind, age] <- (g[ind, age-1]/(lambda[ind] -z[ind, age]))*w[ind, age-1]
}
w[ind, maxAge] <- (g[ind, maxAge]/(lambda[ind] -z[ind, maxAge]))*w[ind, maxAge-1]
#stable state distribution
C[ind, 1:maxAge] <- w[ind, 1:maxAge]/sum(w[ind, 1:maxAge])
#expected counts in each stage class
for(age in 2:(maxAge)){
ey[ind, age] <- g[ind, age-1]*C[ind, age-1] + z[ind, age]*C[ind, age]
}
#ey[ind, maxAge] <- g[ind, maxAge-1]*C[ind, maxAge-1] + survivalProb[ind, maxAge]*C[ind, maxAge]
ey[ind, 1] <- (lambda[ind] - sum(ey[ind, 2:maxAge]))
# likelihood
#theta[ind, 1:maxAge] ~ ddirch(ey[ind, 1:maxAge])
y[ind, 1:maxAge] ~ dmulti(ey[ind, 1:maxAge], harvestCount[ind])
}
}
)
data = list(
# ageAtYear = as.numeric(dataList$sprawningData$ageAtYear),
lengthAtAgeThisYear = lengthAtAgePosteriorSummary$data,
year = as.numeric(scale(dataList$ageAtHarvestData$year)),
y = as.matrix(dataList$ageAtHarvestData[ ,4:17]),
harvestCount = rowSums(as.matrix(dataList$ageAtHarvestData[4:17])),
forest = as.numeric(scale(dataList$ageAtHarvestData$`Coniferous forest`)),
pastures = as.numeric(scale(dataList$ageAtHarvestData$Pastures)),
summerTemp = as.numeric(scale(dataList$ageAtHarvestData$meanSummerTemp)),
#summerPrec = as.numeric(scale(dataList$ageAtHarvestData$summerPrecipitation)),
summerSnowDepth = as.numeric(scale(dataList$ageAtHarvestData$meanWinterSnow)),
popnDensity = as.numeric(scale(dataList$ageAtHarvestData$pop_density)),
forestsq = as.numeric((scale(dataList$ageAtHarvestData$`Coniferous forest`)))^2,
pasturessq = as.numeric((scale(dataList$ageAtHarvestData$Pastures)))^2,
summerTempsq = as.numeric((scale(dataList$ageAtHarvestData$meanSummerTemp)))^2,
#summerPrecsq = as.numeric((scale(dataList$ageAtHarvestData$summerPrecipitation)))^2,
summerSnowDepthsq = as.numeric((scale(dataList$ageAtHarvestData$meanWinterSnow)))^2,
popnDensitysq = as.numeric((scale(dataList$ageAtHarvestData$pop_density)))^2,
WPUE = wpue
)
wpue = as.numeric(scale(dataList$ageAtHarvestData$WPUE))
wpue[is.na(wpue)] <- mean(wpue, na.rm = TRUE)
data = list(
# ageAtYear = as.numeric(dataList$sprawningData$ageAtYear),
lengthAtAgeThisYear = lengthAtAgePosteriorSummary$data,
year = as.numeric(scale(dataList$ageAtHarvestData$year)),
y = as.matrix(dataList$ageAtHarvestData[ ,4:17]),
harvestCount = rowSums(as.matrix(dataList$ageAtHarvestData[4:17])),
forest = as.numeric(scale(dataList$ageAtHarvestData$`Coniferous forest`)),
pastures = as.numeric(scale(dataList$ageAtHarvestData$Pastures)),
summerTemp = as.numeric(scale(dataList$ageAtHarvestData$meanSummerTemp)),
#summerPrec = as.numeric(scale(dataList$ageAtHarvestData$summerPrecipitation)),
summerSnowDepth = as.numeric(scale(dataList$ageAtHarvestData$meanWinterSnow)),
popnDensity = as.numeric(scale(dataList$ageAtHarvestData$pop_density)),
forestsq = as.numeric((scale(dataList$ageAtHarvestData$`Coniferous forest`)))^2,
pasturessq = as.numeric((scale(dataList$ageAtHarvestData$Pastures)))^2,
summerTempsq = as.numeric((scale(dataList$ageAtHarvestData$meanSummerTemp)))^2,
#summerPrecsq = as.numeric((scale(dataList$ageAtHarvestData$summerPrecipitation)))^2,
summerSnowDepthsq = as.numeric((scale(dataList$ageAtHarvestData$meanWinterSnow)))^2,
popnDensitysq = as.numeric((scale(dataList$ageAtHarvestData$pop_density)))^2,
WPUE = wpue
)
constants = list(
nInds = nrow(dataList$ageAtHarvestData),
sexID = as.numeric(dataList$sprawningData$sex),
nSex = length(unique(as.numeric(dataList$sprawningData$sex))),
lakeID = as.numeric(as.factor(dataList$ageAtHarvestData$InnsjoNr)),
nLakes = length(unique(as.numeric(as.factor(dataList$ageAtHarvestData$InnsjoNr)))),
maxAge = dim(data$y)[2]#,
#nSpecies = length(unique(as.numeric(as.factor(dataList$ageAtHarvestData$speciesID))))
)
inits <- list(
psi = rep(0.5, 12),
bsurv = rnorm(13, 0, 1),
bsurvSex = rnorm(constants$nSex, 0, 1),
bsurvAge = rnorm(constants$maxAge, 0, 1),
bsurvLake = rnorm(constants$nLakes, 0,1),
sdbsurvSex = 1,
sdbsurvAge = 1,
sdbsurvLake = 1,
Amat = array(0, dim = c(constants$maxAge,constants$maxAge, constants$nInds)),
spawnProb = 0.1
)
# nimbleModel
fishModel <- nimbleModel(code,
data = data,
constants = constants,
inits = inits)
# compile nimbleModel
fishModelCompiled <- compileNimble(fishModel)
# check if any lambda is 0 or NA
which(fishModelCompiled$lambda == 0)
which(is.na(fishModelCompiled$lambda))
# Configure the model
fishModelConfigured <- configureMCMC(fishModelCompiled,
monitors = c("bsurv",
"bsurvLake",
"bsurvAge",
"bsurvSex",
"sdbsurvLake",
"sdbsurvAge",
"sdbsurvSex",
"lambda",
"survivalProb",
"spawnProb",
"psi")
)
# Build and run model
fishModelBuilt <- buildMCMC(fishModelConfigured)
# compile built model
fishModelCompiled2 <- compileNimble(fishModelBuilt,
project = fishModelCompiled)
#run MCMC
fishModelMCMCrun <- runMCMC(fishModelCompiled2,
niter = 3000,
nchains = 2,
nburnin = 1000,
thin = 2,
setSeed = TRUE,
samples = TRUE,
samplesAsCodaMCMC = TRUE,
summary = TRUE,
WAIC = FALSE)
#check summary
fishModelMCMCrun$summary$all.chains
save(fishModelMCMCrun, file = "result/fittedModel.RData")
source("C:/GitHub/fishyIPMs/NewDataset/modelFittingPipeline/modelFitNew.R", echo=TRUE)
# Load libraries
library(ggplot2)
library(dplyr)
library(latex2exp)
# Set the theme of the ggplot
theme_set(theme_bw())
results <- fishModelMCMCrun$summary$all.chains
# Variable selection probabilities
varSelectionProb <- results[ rownames(results)[grepl("psi", rownames(results))], ]%>%
data.frame()%>%
mutate(covariate = c("year", "forest", "pastures",
"popnDensity", "summerTemp", "summerSnowDepth",
"forestsq", "pasturessq", "popnDensitysq",
"summerTempsq", "summerSnowDepthsq", "WPUE"),
posNeg = ifelse(Mean < 0.4 | Mean > 0.6, "postive", "negative")
)
ggplot(varSelectionProb, aes(x = covariate, y = Mean, colour = posNeg))+
geom_point()+
geom_errorbar(aes(ymin = X95.CI_low,
ymax = X95.CI_upp),
width = .2)+
scale_color_manual("posNeg", breaks=c("postive", "negative"),values=c("#D55E00", "black"))+
geom_hline(yintercept = 0.5, linetype = "dashed", col = "red")+
theme(axis.text.x = element_text(angle = 90,
vjust = 0.6))+
coord_flip() +
theme(legend.position="none")+
ylab("Variable Selection Probablity")
# Covariate effects
covEffects <- results[ rownames(results)[grepl("bsurv", rownames(results))], ]%>%
data.frame()
covEffects[2:13,]%>%
mutate(covariate = c( "year", "forest", "pastures",
"popnDensity", "summerTemp", "summerSnowDepth",
"forestsq", "pasturessq", "popnDensitysq",
"summerTempsq", "summerSnowDepthsq", "WPUE"),
posNeg = ifelse(X95.CI_low < 0 & X95.CI_upp > 0, "postive", "negative")
)%>%
ggplot(., aes(x = covariate, y = Mean, colour = posNeg))+
geom_point()+
geom_errorbar(aes(ymin = Mean - St.Dev.,
ymax = Mean + St.Dev.),
width = .2)+
scale_color_manual("posNeg", breaks=c("postive", "negative"),values=c("black", "#D55E00"))+
#geom_hline(yintercept = 0, linetype = "dashed", col = "red")+
theme(axis.text.x = element_text(angle = 90,
vjust = 0.6))+
coord_flip()+
theme(legend.position="none")+
ylab("Effect")
# Effects of age, sex and lake on survival probability
randomEffects <- results[ rownames(results)[grepl("sd", rownames(results))], ]%>%
data.frame()%>%
mutate(covariate = c("Age", "Lake", "Sex"))%>%
ggplot(., aes(x = covariate, y = Mean))+
geom_point()+
geom_errorbar(aes(ymin = Mean - St.Dev.,
ymax = Mean + St.Dev.),
width = .2)+
coord_flip()
# Lake effects
lakeEffect <- results[ rownames(results)[grepl("bsurvLake", rownames(results))], ]%>%
data.frame()
lakeEffect <- lakeEffect[-nrow(lakeEffect), ]%>%
mutate(lakeID = levels(as.factor(dataList$ageAtHarvestData$InnsjoNr)),
posNeg = ifelse(X95.CI_low < 0 & X95.CI_upp > 0, "postive", "negative"))%>%
ggplot(., aes(x = lakeID, y = Mean, colour = posNeg))+
geom_point()+
geom_errorbar(aes(ymin = X95.CI_low,
ymax = X95.CI_upp),
width = .2)+
scale_color_manual("posNeg", breaks=c("postive", "negative"),values=c("black", "#D55E00"))+
coord_flip() +
theme(legend.position="none")+
ylab(TeX(sprintf("Mean $\\pm 95$ CI")))
lakeEffect
# Population growth rate by sex and year
popnGrowthRate <- results[ rownames(results)[grepl("lambda", rownames(results))], ] %>%
cbind(dataList$ageAtHarvestData[,1:3], .) %>%
data.frame()%>%
dplyr::group_by(year, sex)%>%
summarise_at(., c("Mean", "St.Dev.", "X95.CI_low", "X95.CI_upp"), "mean")%>%
ggplot(., aes(x = year, y = Mean, color = as.factor(sex)))+
geom_point()+
geom_line()
# Population growth rate  and year
popnGrowthRate <- results[ rownames(results)[grepl("lambda", rownames(results))], ] %>%
cbind(dataList$ageAtHarvestData[,1:3], .) %>%
data.frame()%>%
dplyr::group_by(year)%>%
summarise_at(., c("Mean", "St.Dev.", "X95.CI_low", "X95.CI_upp"), "mean")%>%
ggplot(., aes(x = as.factor(year), y = Mean))+
geom_point()+
geom_line()
# Spawning probability
results[ rownames(results)[grepl("spawn", rownames(results))], ]
popnGrowthRate
# Population growth rate by sex and year
popnGrowthRate <- results[ rownames(results)[grepl("lambda", rownames(results))], ] %>%
cbind(dataList$ageAtHarvestData[,1:3], .) %>%
data.frame()%>%
dplyr::group_by(year, sex)%>%
summarise_at(., c("Mean", "St.Dev.", "X95.CI_low", "X95.CI_upp"), "mean")%>%
ggplot(., aes(x = year, y = Mean, color = as.factor(sex)))+
geom_point()+
geom_line()
popnGrowthRate
save(fishModelMCMCrun, file = "result/fittedModelWithoutOverdispersion.RData")
source("C:/GitHub/fishyIPMs/NewDataset/modelFittingPipeline/modelFitNew.R", echo=TRUE)
# Load libraries
library(ggplot2)
library(dplyr)
library(latex2exp)
# Set the theme of the ggplot
theme_set(theme_bw())
# Load data
load("result/fittedModelWithOverdispersion.RData")
# Load formatted data
load("dataset/formattedDataList.RData")
results <- fishModelMCMCrun$summary$all.chains
# Variable selection probabilities
varSelectionProb <- results[ rownames(results)[grepl("psi", rownames(results))], ]%>%
data.frame()%>%
mutate(covariate = c("year", "forest", "pastures",
"popnDensity", "summerTemp", "summerSnowDepth",
"forestsq", "pasturessq", "popnDensitysq",
"summerTempsq", "summerSnowDepthsq", "WPUE"),
posNeg = ifelse(Mean < 0.4 | Mean > 0.6, "postive", "negative")
)
ggplot(varSelectionProb, aes(x = covariate, y = Mean, colour = posNeg))+
geom_point()+
geom_errorbar(aes(ymin = X95.CI_low,
ymax = X95.CI_upp),
width = .2)+
scale_color_manual("posNeg", breaks=c("postive", "negative"),values=c("#D55E00", "black"))+
geom_hline(yintercept = 0.5, linetype = "dashed", col = "red")+
theme(axis.text.x = element_text(angle = 90,
vjust = 0.6))+
coord_flip() +
theme(legend.position="none")+
ylab("Variable Selection Probablity")
varSelectionProb
as.numeric(scale(dataList$ageAtHarvestData$year))
stagedData
setwd("C:/Users/kwaku.adjei/Dropbox/ReviewedArticles/ReviewPaperTwo")
